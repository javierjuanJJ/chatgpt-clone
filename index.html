<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chat gpt local 100% privado gratis y maravilloso</title>
    <style>
        body {
            font-family: System-ui;
            /* Prioriza la fuente del sistema [12] */
            background: #f0f0f0;
            /* Gris claro [13] */
            display: grid;
            place-content: center;
            height: 100dvh;
            /* Altura dinámica del viewport (Dynamic View High) [13, 14] */
        }

        main {
            width: 100%;
            /* ... otros estilos de separación ... */
            overflow: auto;
            /* Muestra scroll si el contenido desborda [15] */
        }

        .lista de mensajes {
            display: flex;
            flex-direction: column;
            list-style: none;
            /* Quitar viñetas */
            padding: 0;
        }

        /* Estilo para cada mensaje (Li) */
        .message {
            display: flex;
            flex-direction: column;
            margin: 0 0 16px 0;
            /* Separación entre mensajes [16] */
            padding: 8px 12px;
        }

        .message>span:first-child {
            /* Estilos del remitente (GPT o tú) */
            /* ... Sizing, centering, semi-bold font ... */
            border-radius: 9999px;
            /* Para que quede redondo [17] */
            /* ... Background color, size ... */
        }

        .message p {
            /* El párrafo que contiene el texto del mensaje [11] */
            margin-top: 8px;
            /* Separación con el remitente [17] */
        }

        .user {
            align-self: flex-end;
            /* Alineación a la derecha [17] */
            align-items: flex-end;
            background-color: blue;
            /* Ejemplo de color [18] */
        }

        .Bot {
            align-self: flex-start;
            /* Alineación a la izquierda [18] */
            background-color: green;
            /* Ejemplo de color [18] */
        }

        form {
            display: flex;
        }

        form input {
            /* Usando el nested selector implícito */
            border-radius: 9px;
            flex-grow: 1;
            /* Para que el input se expanda [20] */
            border: 0;
            padding: 8px;
            margin: 8px;
            /* ... Otros estilos ... */
        }

        form button {
            background: black
                /* color */
            ;
            border: 0;
            color: white;
            cursor: Pointer;
            /* ... otros estilos ... */
        }

        form button:hover {
            /* Usando el ampersand (&) para referirse al padre (button) [21] */
            background: green
                /* slightly darker color */
            ;
            transition: background 0.3s;
        }
    </style>
</head>

<body>
    <main>
        <ul class="lista de mensajes">
            <template id="message-template">
                <!-- Este <li> se convierte en la clase .message [9] -->
                <li>
                    <span></span> <!-- Para el remitente (gpt o tú) [10] -->
                    <p></p> <!-- Para el texto del mensaje (corregido desde el span original) [10, 11] -->
                </li>
            </template>
        </ul>
    </main>

    <form>
        <!-- El type="text" es opcional/por defecto y se puede omitir -->
        <input placeholder="Escribe tu mensaje aquí">
        <button disabled>enviar</button>
        <!-- El botón se pone deshabilitado por defecto y se activa al cargar el modelo [5] -->
    </form>

    <small></small>


</body>
<script type="module">
    // Función de utilidad para seleccionar elementos (simulando jQuery) [24]
    const $ = (selector) => document.querySelector(selector);

    // Variables de estado [5]
    let messages = [];

    // Variables del DOM [24, 25]
    const $form = $('form');
    const $input = $('input');
    const $template = $('#message-template');
    const $messages = $('ul');
    const $button = $('button');
    const $small = $('small');

    // El resto del código JS sigue aquí...

    $form.addEventListener('submit', async (event) => {
        event.preventDefault();
        $button.setAttribute('disabled', ''); // Deshabilita el botón mientras se procesa [28]

        const messageText = $input.value.trim();
        if (messageText !== '') {
            // 1. Añadir mensaje de usuario a la lista y al DOM [29]
            const userMessage = { role: 'user', content: messageText };
            messages.push(userMessage);
            addMessage({ text: messageText, sender: 'user' });

            // 2. Procesar respuesta del Bot (Implementado en Capítulos 12/13)
            // ...

            // 3. Resetear input [27]
            $input.value = '';

            // Llamada al motor LLM para obtener la respuesta en streaming [44, 45]
            const chunks = await engine.chat.completions.create({
                messages: messages,
                stream: true
            });

            let reply = '';
            // 1. Añadir un mensaje Bot vacío y obtener su elemento P para actualizarlo [34, 46]
            const $botMessageText = addMessage({ text: '', sender: 'Bot' });

            // 2. Iterar sobre los chunks de la respuesta [45]
            for await (const chunk of chunks) {
                const choice = chunk.choices;
                // Recuperar el contenido, usando optional chaining y nullish coalescing [46, 47]
                const content = choice.delta?.content ?? '';

                reply += content;
                $botMessageText.textContent = reply; // Actualizar el DOM en tiempo real [34]
                $messages.scrollTop = $messages.scrollHeight; // Mantener el scroll al fondo [33, 48]
            }

            // 3. Guardar la respuesta completa del Bot en la historia [49]
            messages.push({ role: 'assistant', content: reply });

            // 4. Re-activar el botón [28]
            $button.removeAttribute('disabled');
        }
    });

    const addMessage = ({ text, sender }) => {
        // Clonación profunda del template [30]
        const cloneTemplate = $template.content.cloneNode(true);
        const newMessage = cloneTemplate.querySelector('li'); // Recuperar el elemento message (li) [9]

        // Recuperar elementos internos [10]
        const $header = newMessage.querySelector('span');
        const $text = newMessage.querySelector('p');

        // Actualizar contenido y clase [10, 31]
        $header.textContent = sender === 'Bot' ? 'gpt' : 'tú';
        $text.textContent = text;
        newMessage.classList.add(sender);

        // Añadir al DOM y gestionar scroll [31-33]
        $messages.appendChild(newMessage);
        $messages.scrollTop = $messages.scrollHeight;

        return $text; // Retorna el elemento P para el streaming [34]
    };

    // CSS adicional para scroll suave: scroll-behavior: Smooth; (aplicado al contenedor de mensajes) [33]

    // Importación de la librería (la URL específica puede variar, pero se utiliza el import de módulos) [38, 39]
    import { createWebWorkerEngine } from 'https://cdn.jsdelivr.net/npm/@mlc-ai/web-llm@0.2.49/dist/web-llm.js';

    // Modelo seleccionado (Ejemplo de Llama 3) [40, 41]
    const selectedModel = 'Llama-3-8B-Instruct-q4f32_1-MLC';

    // Configuración del Worker [37]
    const worker = new Worker('worker.js', { type: 'module' }); // Debe ser tipo 'module' para imports internos

    // Inicialización del motor LLM a través del Web Worker (Asíncrono) [36, 37]
    const engine = await createWebWorkerEngine(worker, selectedModel, {
        initProgressCallback: (info) => {
            // Muestra progreso de carga en el elemento small [25, 42]
            $small.textContent = info.text;

            // Activa el botón al terminar la carga [5]
            if (info.progress === 1) {
                $button.removeAttribute('disabled');
            }
        }
    });




</script>

</html>